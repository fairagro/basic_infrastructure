# oidc_login_provider_url: "https://keycloak.corki.bonares.de/realms/fairagro"
# #oidc_login_logout_url: "https://keycloak.corki.bonares.de/realms/fairagro/protocol/openid-connect/logout"
# oidc_login_logout_url: "https://nextcloud.corki.bonares.de/login"
# oidc_login_client_secret: "eoqeT1vQfBDoEDOEMEkRKul6BAF4aYSN"
oidc_login_client_id: nextcloud

# tls:
#   certificate:
#   key:

# ## Liveness and readiness probe values
# ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
# ##
nextcloud:
  image:
    # Here we're actually using a hack:
    # The nextcloud helm chart does not support specifying an image digest hash. So we rely on the fact
    # that the image name is built by concatenating the repository name and the tag, using a colon as separator.
    # Now we can simply add the @sha256 to the repository name and specify the image digest hash in the tag.
    # This works as long as the repository name is only referenced within the chart for generating the image name.
    repository: nextcloud@sha256
    # I would prefer to go for the fpm-alpine version, because it has much less vulnerabilities.
    # This requires to install nginx as sidecar container. But currently I receive HTTP 500 when trying this.
    #tag: 0b04a2e2c14672a2fe56ca668a633ed8fc9d2d882df83fdfc6114773f4713a74 # 28.0.2-apache
    tag: d0d13d935eaa9219bfa89fd8213b3ede6431e04685f0a25f6f764f5e5dcfe990 # 28.0.2-fpm-alpine
    pullPolicy: IfNotPresent

  nextcloud:
    # podSecurityContext:
    #   runAsUser: 101 # this is the nginx user in the nginx container
    #   runAsGroup: 101
    #   fsGroup: 101
    #   runAsNonRoot: true
    #   readOnlyRootFilesystem: false
    extraEnv:
      # Fix the postgres connection issue
      # "could not open certificate file "/root/.postgresql/postgresql.crt": Permission denied"
      # according to https://meta.discourse.org/t/trouble-bootstrapping-with-rds-could-not-open-certificate-file/289367
      - name: PGSSLCERT
        value: /tmp/postgresql.crt
    configs:
      phone.config.php: |-
        <?php
        $CONFIG = array (
          'default_phone_region' => 'DE',
        );
      cron.config.php: |-
        <?php
        $CONFIG = array (
          'maintenance_window_start' => 1,     // run background jobs at 1am
        );
      proxy.config.php: |-
        <?php
        $CONFIG = array (
          'trusted_proxies' => array(
            0 => '127.0.0.1',
            1 => '10.0.0.0/8',
          ),
          'forwarded_for_headers' => array('HTTP_X_FORWARDED_FOR'),
        );
      protocol.config.php: |-
        <?php
        $CONFIG = array (
          'overwriteprotocol' => 'https'
        );
      # {{- if and .Values.oidc_login_provider_url .Values.oidc_login_logout_url .Values.oidc_login_client_secret }}
      #   oidc.config.php: |-
      #     <?php
      #     $CONFIG = array (
      #       // Some Nextcloud options that might make sense here
      #       'allow_user_to_change_display_name' => false,
      #       'lost_password_link' => 'disabled',

      #       // URL of provider. All other URLs are auto-discovered from .well-known
      #       'oidc_login_provider_url' => '{{ .Values.oidc_login_provider_url }}',

      #       // Client ID and secret registered with the provider
      #       'oidc_login_client_id' => '{{ .Values.oidc_login_client_id }}',
      #       'oidc_login_client_secret' => '{{ .Values.oidc_login_client_secret }}',

      #       // Automatically redirect the login page to the provider
      #       'oidc_login_auto_redirect' => true,

      #       // Redirect to this page after logging out the user
      #       'oidc_login_logout_url' => '{{ .Values.oidc_login_logout_url }}',

      #       // If set to true the user will be redirected to the
      #       // logout endpoint of the OIDC provider after logout
      #       // in Nextcloud. After successfull logout the OIDC
      #       // provider will redirect back to 'oidc_login_logout_url' (MUST be set).
      #       'oidc_login_end_session_redirect' => true,

      #       // Quota to assign if no quota is specified in the OIDC response (bytes)
      #       //
      #       // NOTE: If you want to allow NextCloud to manage quotas, omit this option. Do not set it to
      #       // zero or -1 or ''.
      #       //'oidc_login_default_quota' => '1000000000',

      #       // Login button text
      #       'oidc_login_button_text' => 'Log in with OpenID',

      #       // Hide the NextCloud password change form.
      #       'oidc_login_hide_password_form' => true,

      #       // Use ID Token instead of UserInfo
      #       'oidc_login_use_id_token' => false,

      #       // Attribute map for OIDC response. Available keys are:
      #       //   * id:           Unique identifier for username
      #       //   * name:         Full name
      #       //                      If set to null, existing display name won't be overwritten
      #       //   * mail:         Email address
      #       //                      If set to null, existing email address won't be overwritten
      #       //   * quota:        Nextcloud storage quota
      #       //   * home:         Home directory location. A symlink or external storage to this location is used
      #       //   * ldap_uid:     LDAP uid to search for when running in proxy mode
      #       //   * groups:       Array or space separated string of NC groups for the user
      #       //   * login_filter: Array or space separated string. If 'oidc_login_filter_allowed_values' is
      #       //                      set, it is checked against these values.
      #       //   * photoURL:     The URL of the user avatar. The nextcloud server will download the picture
      #       //                      at user login. This may lead to security issues. Use with care.
      #       //                      This will only be effective if oidc_login_update_avatar is enabled.
      #       //   * is_admin:     If this value is truthy, the user is added to the admin group (optional)
      #       //
      #       // The attributes in the OIDC response are flattened by adding the nested
      #       // array key as the prefix and an underscore. Thus,
      #       //
      #       //     $profile = [
      #       //         'id' => 1234,
      #       //         'attributes' => [
      #       //             'uid' => 'myuid',
      #       //             'abc' => 'xyz'
      #       //         ],
      #       //         'list' => ['one', 'two']
      #       //     ];
      #       //
      #       // would become,
      #       //
      #       //     $profile = [
      #       //         'id' => 1234,
      #       //         'attributes' => [
      #       //             'uid' => 'myuid',
      #       //             'abc' => 'xyz'
      #       //         ],
      #       //         'attributes_uid' => 'myuid',
      #       //         'attributes_abc' => 'xyz',
      #       //         'list' => ['one', 'two'],
      #       //         'list_0' => 'one',
      #       //         'list_1' => 'two',
      #       //         'list_one' => 'one',
      #       //         'list_two' => 'two',
      #       //     ]
      #       //
      #       // https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
      #       //
      #       // note: on Keycloak, OIDC name claim = "${given_name} ${family_name}" or one of them if any is missing
      #       //
      #       'oidc_login_attributes' => array (
      #           'id' => 'preferred_username',
      #           'name' => 'name',
      #           'mail' => 'email',
      #           //'quota' => 'ownCloudQuota',
      #           //'home' => 'homeDirectory',
      #           //'ldap_uid' => 'uid',
      #           'groups' => 'nextCloudGroups',
      #           //'login_filter' => 'nextCloudGroups',
      #           //'photoURL' => 'picture',
      #           //'is_admin' => 'ownCloudAdmin',
      #       ),

      #       // Default group to add users to (optional, defaults to nothing)
      #       //'oidc_login_default_group' => 'oidc',

      #       // DEPRECATED: This option will be removed in a future release. Use
      #       // 'login_filter' and 'oidc_login_filter_allowed_values' instead.
      #       //
      #       // Allow only users in configured group(s) to access Nextcloud. In case the user
      #       // is not assigned to this group (read from oidc_login_attributes) the login
      #       // will not be allowed for this user.
      #       //
      #       // Must be specified as an array of groups that are allowed to access Nextcloud.
      #       // e.g. 'oidc_login_allowed_groups' => array('group1', 'group2')
      #       'oidc_login_allowed_groups' => array('user', 'admin'),

      #       // Allow only users in configured value(s) to access Nextcloud. In case the user
      #       // is not assigned to this value (read from oidc_login_attributes) the login
      #       // will not be allowed for this user.
      #       //
      #       // Must be specified as an array of values (e.g. roles) that are allowed to
      #       // access Nextcloud. e.g. 'oidc_login_filter_allowed_values' => array('role1', 'role2')
      #       // 'oidc_login_filter_allowed_values' => array('user', 'admin'),

      #       // Use external storage instead of a symlink to the home directory
      #       // Requires the files_external app to be enabled
      #       'oidc_login_use_external_storage' => false,

      #       // Set OpenID Connect scope
      #       'oidc_login_scope' => 'profile email',    // the scope 'openid' is always added automatically

      #       // Run in LDAP proxy mode
      #       // In this mode, instead of creating users of its own, OIDC login
      #       // will get the existing user from an LDAP database and only
      #       // perform authentication with OIDC. All user data will be derived
      #       // from the LDAP database instead of the OIDC user response
      #       //
      #       // The `id` attribute in `oidc_login_attributes` must return the
      #       // "Internal Username" (see expert settings in LDAP integration)
      #       'oidc_login_proxy_ldap' => false,

      #       // Disable creation of users new to Nextcloud from OIDC login.
      #       // A user may be known to the IdP but not (yet) known to Nextcloud.
      #       // This setting controls what to do in this case.
      #       // - 'true' (default): if the user authenticates to the IdP but is not known to Nextcloud,
      #       //     then they will be returned to the login screen and not allowed entry;
      #       // - 'false': if the user authenticates but is not yet known to Nextcloud,
      #       //     then the user will be automatically created; note that with this setting,
      #       //     you will be allowing (or relying on) a third-party (the IdP) to create new users
      #       'oidc_login_disable_registration' => false,

      #       // Fallback to direct login if login from OIDC fails
      #       // Note that no error message will be displayed if enabled
      #       'oidc_login_redir_fallback' => false,

      #       // Use an alternative login page
      #       // This page will be php-included instead of a redirect if specified
      #       // In the example below, the PHP file `login.php` in `assets`
      #       // in nextcloud base directory will be included
      #       // Note: the PHP variable $OIDC_LOGIN_URL is available for redirect URI
      #       // Note: you may want to try setting `oidc_login_logout_url` to your
      #       // base URL if you face issues regarding re-login after logout
      #       'oidc_login_alt_login_page' => 'assets/login.php',

      #       // For development, you may disable TLS verification. Default value is `true`
      #       // which should be kept in production
      #       'oidc_login_tls_verify' => false,

      #       // If you get your groups from the oidc_login_attributes, you might want
      #       // to create them if they are not already existing, Default is `false`.
      #       'oidc_create_groups' => true,

      #       // Enable use of WebDAV via OIDC bearer token.
      #       'oidc_login_webdav_enabled' => false,

      #       // Enable authentication with user/password for DAV clients that do not
      #       // support token authentication (e.g. DAVxâµ)
      #       'oidc_login_password_authentication' => false,

      #       // The time in seconds used to cache public keys from provider.
      #       // The default value is 1 day.
      #       'oidc_login_public_key_caching_time' => 86400,

      #       // The minimum time in seconds to wait between requests to the jwks_uri endpoint.
      #       // Avoids that the provider will be DoSed when someone requests with unknown kids.
      #       // The default is 10 seconds.
      #       'oidc_login_min_time_between_jwks_requests' => 10,

      #       // The time in seconds used to cache the OIDC well-known configuration from the provider.
      #       // The default value is 1 day.
      #       'oidc_login_well_known_caching_time' => 86400,

      #       // If true, nextcloud will download user avatars on login.
      #       // This may lead to security issues as the server does not control
      #       // which URLs will be requested. Use with care.
      #       'oidc_login_update_avatar' => false,

      #       // If true, the default Nextcloud proxy won't be used to make internals OIDC call.
      #       // The default is false.
      #       'oidc_login_skip_proxy' => false,

      #       // Code challenge method for PKCE flow.
      #       // Possible values are:
      #       //	- 'S256'
      #       //	- 'plain'
      #       // The default value is empty, which won't apply the PKCE flow.
      #       'oidc_login_code_challenge_method' => '',
      #     );
      # {{- end }}
      install_or_activate_nextcloud_apps.sh: |-
        #!/bin/bash

        # Array of Nextcloud app names to install (from command line arguments)
        apps=( "$@" )

        # Nextcloud installation details
        nextcloud_path="/var/www/html"
        nextcloud_occ_command="php $nextcloud_path/occ"
        nextcloud_url="http://localhost/status.php"

        # Function to check if Nextcloud is running
        function is_nextcloud_running() {
            curl -s --head "$nextcloud_url" | grep "200 OK" > /dev/null
        }

        echo "Waiting for Nextcloud to be running..."
        until is_nextcloud_running; do
            sleep 1
        done

        # Query installed apps
        nextcloud_installed_apps="$($nextcloud_occ_command app:list)"

        # Loop through the apps array and install/update each app
        for app in "${apps[@]}"
        do
            echo "Checking $app..."
            app_status="$(echo "$nextcloud_installed_apps" | sed -n -e "/^[^:]*:$/h;/$app/{x;p}")"
            if [[ -z $app_status ]]; then
                echo "Installing $app..."
                install_status="$($nextcloud_occ_command app:install $app)"
                if [[ $install_status =~ "installed" ]]; then
                    echo "Installed $app"
                else
                    echo "Failed to install $app"
                fi
            else
                echo "$app is already installed. Checking for updates..."
                update_status="$($nextcloud_occ_command app:update $app)"
                if [[ $update_status =~ "updated" ]]; then
                    echo "Updated $app"
                else
                    echo "$app is up to date"
                fi
            fi
            if [[ $app_status =~ "Disabled" ]]; then
                echo "Enabling $app..."
                enable_status="$($nextcloud_occ_command app:enable $app)"
                if [[ $enable_status =~ "enabled" ]]; then
                    echo "Enabled $app"
                else
                    echo "Failed to enable $app"
                fi
            fi
        done

  resources:
    limits:
      cpu: 2
      memory: 4Gi
    requests:
      cpu: 2
      memory: 4Gi

  livenessProbe:
    enabled: true
    initialDelaySeconds: 0
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    enabled: true
    initialDelaySeconds: 0
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  startupProbe: # the entrypoint copies 600MB data to the NFS volumes which may take some time
    enabled: true
    initialDelaySeconds: 0
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 500
    successThreshold: 1

  # ## Enable persistence using Persistent Volume Claims
  # ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  # ##
  persistence:
    # #   # Nextcloud Data (/var/www/html)
    enabled: true
    # #   annotations: {}
    # #   ## nextcloud data Persistent Volume Storage Class
    # #   ## If defined, storageClassName: <storageClass>
    # #   ## If set to "-", storageClassName: "", which disables dynamic provisioning
    # #   ## If undefined (the default) or set to null, no storageClassName spec is
    # #   ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    # #   ##   GKE, AWS & OpenStack)
    # #   ##
    storageClass: nfs-csi-delete

  nginx:
    enabled: true
    image:
      repository: nginxinc/nginx-unprivileged@sha256
      # tag: cb0953165f59b5cf2227ae979a49a2284956d997fad4ed7a338eebc6aef3e70b # 1.25.4-alpine2.18
      tag: a2e2a031969b6fc6107537901a04c354b38e1708ba3a5e1042b390277b55780e # 1.25.4-bookworm -- there are no alpine versions of unprivileged nginx images
      pullPolicy: IfNotPresent
    config:
      default: false
      custom: |-
        worker_processes auto;

        error_log  /var/log/nginx/error.log warn;
        pid        /var/run/nginx.pid;


        events {
            worker_connections  1024;
        }


        http {
            include       /etc/nginx/mime.types;
            default_type  application/octet-stream;
            types {
              text/javascript js mjs;
            }

            log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                              '$status $body_bytes_sent "$http_referer" '
                              '"$http_user_agent" "$http_x_forwarded_for"';

            access_log  /var/log/nginx/access.log  main;

            sendfile        on;
            #tcp_nopush     on;

            keepalive_timeout  65;

            #gzip  on;

            upstream php-handler {
                server 127.0.0.1:9000;
            }

            server {
                listen 80;

                # HSTS settings
                # WARNING: Only add the preload option once you read about
                # the consequences in https://hstspreload.org/. This option
                # will add the domain to a hardcoded list that is shipped
                # in all major browsers and getting removed from this list
                # could take several months.
                #add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;" always;

                # set max upload size
                client_max_body_size 10G;
                fastcgi_buffers 64 4K;

                # Enable gzip but do not remove ETag headers
                gzip on;
                gzip_vary on;
                gzip_comp_level 4;
                gzip_min_length 256;
                gzip_proxied expired no-cache no-store private no_last_modified no_etag auth;
                gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy;

                # Pagespeed is not supported by Nextcloud, so if your server is built
                # with the `ngx_pagespeed` module, uncomment this line to disable it.
                #pagespeed off;

                # HTTP response headers borrowed from Nextcloud `.htaccess`
                add_header Referrer-Policy                      "no-referrer"       always;
                add_header X-Content-Type-Options               "nosniff"           always;
                add_header X-Download-Options                   "noopen"            always;
                add_header X-Frame-Options                      "SAMEORIGIN"        always;
                add_header X-Permitted-Cross-Domain-Policies    "none"              always;
                add_header X-Robots-Tag                         "noindex, nofollow" always;
                add_header X-XSS-Protection                     "1; mode=block"     always;

                # Remove X-Powered-By, which is an information leak
                fastcgi_hide_header X-Powered-By;

                # Path to the root of your installation
                root /var/www/html;

                # Specify how to handle directories -- specifying `/index.php$request_uri`
                # here as the fallback means that Nginx always exhibits the desired behaviour
                # when a client requests a path that corresponds to a directory that exists
                # on the server. In particular, if that directory contains an index.php file,
                # that file is correctly served; if it doesn't, then the request is passed to
                # the front-end controller. This consistent behaviour means that we don't need
                # to specify custom rules for certain paths (e.g. images and other assets,
                # `/updater`, `/ocm-provider`, `/ocs-provider`), and thus
                # `try_files $uri $uri/ /index.php$request_uri`
                # always provides the desired behaviour.
                index index.php index.html /index.php$request_uri;

                # Rule borrowed from `.htaccess` to handle Microsoft DAV clients
                location = / {
                    if ( $http_user_agent ~ ^DavClnt ) {
                        return 302 /remote.php/webdav/$is_args$args;
                    }
                }

                location = /robots.txt {
                    allow all;
                    log_not_found off;
                    access_log off;
                }

                # Make a regex exception for `/.well-known` so that clients can still
                # access it despite the existence of the regex rule
                # `location ~ /(\.|autotest|...)` which would otherwise handle requests
                # for `/.well-known`.
                location ^~ /.well-known {
                    # The following 6 rules are borrowed from `.htaccess`

                    location = /.well-known/carddav     { return 301 /remote.php/dav/; }
                    location = /.well-known/caldav      { return 301 /remote.php/dav/; }
                    # Anything else is dynamically handled by Nextcloud
                    location ^~ /.well-known            { return 301 /index.php$uri; }

                    try_files $uri $uri/ =404;
                }

                # Rules borrowed from `.htaccess` to hide certain paths from clients
                location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)(?:$|/)  { return 404; }
                location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console)              { return 404; }

                # Ensure this block, which passes PHP files to the PHP process, is above the blocks
                # which handle static assets (as seen below). If this block is not declared first,
                # then Nginx will encounter an infinite rewriting loop when it prepends `/index.php`
                # to the URI, resulting in a HTTP 500 error response.
                location ~ \.php(?:$|/) {
                    # Required for legacy support
                    rewrite ^/(?!index|remote|public|cron|core\/ajax\/update|status|ocs\/v[12]|updater\/.+|oc[ms]-provider\/.+|.+\/richdocumentscode\/proxy) /index.php$request_uri;

                    fastcgi_split_path_info ^(.+?\.php)(/.*)$;
                    set $path_info $fastcgi_path_info;

                    try_files $fastcgi_script_name =404;

                    include fastcgi_params;
                    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                    fastcgi_param PATH_INFO $path_info;
                    #fastcgi_param HTTPS on;

                    fastcgi_param modHeadersAvailable true;         # Avoid sending the security headers twice
                    fastcgi_param front_controller_active true;     # Enable pretty urls
                    fastcgi_pass php-handler;

                    fastcgi_intercept_errors on;
                    fastcgi_request_buffering off;
                }

                location ~ \.(?:css|js|svg|gif)$ {
                    try_files $uri /index.php$request_uri;
                    expires 6M;         # Cache-Control policy borrowed from `.htaccess`
                    access_log off;     # Optional: Don't log access to assets
                }

                location ~ \.woff2?$ {
                    try_files $uri /index.php$request_uri;
                    expires 7d;         # Cache-Control policy borrowed from `.htaccess`
                    access_log off;     # Optional: Don't log access to assets
                }

                location / {
                    try_files $uri $uri/ /index.php$request_uri;
                }
            }
        }

  internalDatabase:
    enabled: false

  externalDatabase:
    enabled: true
    type: postgresql
    host: fairagro-postgresql-nextcloud
    database: nextcloud
    existingSecret:
      enabled: true
      secretName: nextcloud.fairagro-postgresql-nextcloud.credentials.postgresql.acid.zalan.do
      usernameKey: username
      passwordKey: password

  cronjob:
    enabled: true
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 100m
        memory: 128Mi
    # securityContext:
    #   runAsUser: 0
    #   runAsGroup: 0
    #   runAsNonRoot: false
    #   readOnlyRootFilesystem: true

    # extraEnv:
    #   PGSSLMODE: require
    #   PGSSLCERT: /etc/tls/tls.crt
    #   PGSSLKEY: /etc/tls/tls.key
