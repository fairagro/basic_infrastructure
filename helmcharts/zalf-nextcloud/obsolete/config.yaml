# This config map overrides the corresponding confic map in the dependency chart.
# The source code is copied by augmented by key 'oidc.config.php'.
# WARNING: in case the dependency chart changes with future release this file
# might need to be adapted.

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "nextcloud.fullname" . }}-config
  labels:
    app.kubernetes.io/name: {{ include "nextcloud.name" . }}
    helm.sh/chart: {{ include "nextcloud.chart" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
data:
# These are additional settings added by zalf-nextcloud chart
  proxy.config.php: |-
    <?php
    $CONFIG = array (
      'trusted_proxies' => array(
        0 => '127.0.0.1',
        1 => '10.0.0.0/8',
      ),
      'forwarded_for_headers' => array('HTTP_X_FORWARDED_FOR'),
    );
  protocol.config.php: |-
    <?php
    $CONFIG = array (
      'overwriteprotocol' => 'https'
    );
{{- if and .Values.oidc_login_provider_url .Values.oidc_login_logout_url .Values.oidc_login_client_secret }}
  oidc.config.php: |-
    <?php
    $CONFIG = array (
      // Some Nextcloud options that might make sense here
      'allow_user_to_change_display_name' => false,
      'lost_password_link' => 'disabled',

      // URL of provider. All other URLs are auto-discovered from .well-known
      'oidc_login_provider_url' => '{{ .Values.oidc_login_provider_url }}',

      // Client ID and secret registered with the provider
      'oidc_login_client_id' => '{{ .Values.oidc_login_client_id }}',
      'oidc_login_client_secret' => '{{ .Values.oidc_login_client_secret }}',

      // Automatically redirect the login page to the provider
      'oidc_login_auto_redirect' => true,

      // Redirect to this page after logging out the user
      'oidc_login_logout_url' => '{{ .Values.oidc_login_logout_url }}',

      // If set to true the user will be redirected to the
      // logout endpoint of the OIDC provider after logout
      // in Nextcloud. After successfull logout the OIDC
      // provider will redirect back to 'oidc_login_logout_url' (MUST be set).
      'oidc_login_end_session_redirect' => true,

      // Quota to assign if no quota is specified in the OIDC response (bytes)
      //
      // NOTE: If you want to allow NextCloud to manage quotas, omit this option. Do not set it to
      // zero or -1 or ''.
      //'oidc_login_default_quota' => '1000000000',

      // Login button text
      'oidc_login_button_text' => 'Log in with OpenID',

      // Hide the NextCloud password change form.
      'oidc_login_hide_password_form' => true,

      // Use ID Token instead of UserInfo
      'oidc_login_use_id_token' => false,

      // Attribute map for OIDC response. Available keys are:
      //   * id:           Unique identifier for username
      //   * name:         Full name
      //                      If set to null, existing display name won't be overwritten
      //   * mail:         Email address
      //                      If set to null, existing email address won't be overwritten
      //   * quota:        Nextcloud storage quota
      //   * home:         Home directory location. A symlink or external storage to this location is used
      //   * ldap_uid:     LDAP uid to search for when running in proxy mode
      //   * groups:       Array or space separated string of NC groups for the user
      //   * login_filter: Array or space separated string. If 'oidc_login_filter_allowed_values' is
      //                      set, it is checked against these values.
      //   * photoURL:     The URL of the user avatar. The nextcloud server will download the picture
      //                      at user login. This may lead to security issues. Use with care.
      //                      This will only be effective if oidc_login_update_avatar is enabled.
      //   * is_admin:     If this value is truthy, the user is added to the admin group (optional)
      //
      // The attributes in the OIDC response are flattened by adding the nested
      // array key as the prefix and an underscore. Thus,
      //
      //     $profile = [
      //         'id' => 1234,
      //         'attributes' => [
      //             'uid' => 'myuid',
      //             'abc' => 'xyz'
      //         ],
      //         'list' => ['one', 'two']
      //     ];
      //
      // would become,
      //
      //     $profile = [
      //         'id' => 1234,
      //         'attributes' => [
      //             'uid' => 'myuid',
      //             'abc' => 'xyz'
      //         ],
      //         'attributes_uid' => 'myuid',
      //         'attributes_abc' => 'xyz',
      //         'list' => ['one', 'two'],
      //         'list_0' => 'one',
      //         'list_1' => 'two',
      //         'list_one' => 'one',
      //         'list_two' => 'two',
      //     ]
      //
      // https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
      //
      // note: on Keycloak, OIDC name claim = "${given_name} ${family_name}" or one of them if any is missing
      //
      'oidc_login_attributes' => array (
          'id' => 'preferred_username',
          'name' => 'name',
          'mail' => 'email',
          //'quota' => 'ownCloudQuota',
          //'home' => 'homeDirectory',
          //'ldap_uid' => 'uid',
          'groups' => 'nextCloudGroups',
          //'login_filter' => 'nextCloudGroups',
          //'photoURL' => 'picture',
          //'is_admin' => 'ownCloudAdmin',
      ),

      // Default group to add users to (optional, defaults to nothing)
      //'oidc_login_default_group' => 'oidc',

      // DEPRECATED: This option will be removed in a future release. Use
      // 'login_filter' and 'oidc_login_filter_allowed_values' instead.
      //
      // Allow only users in configured group(s) to access Nextcloud. In case the user
      // is not assigned to this group (read from oidc_login_attributes) the login
      // will not be allowed for this user.
      //
      // Must be specified as an array of groups that are allowed to access Nextcloud.
      // e.g. 'oidc_login_allowed_groups' => array('group1', 'group2')
      'oidc_login_allowed_groups' => array('user', 'admin'),

      // Allow only users in configured value(s) to access Nextcloud. In case the user
      // is not assigned to this value (read from oidc_login_attributes) the login
      // will not be allowed for this user.
      //
      // Must be specified as an array of values (e.g. roles) that are allowed to
      // access Nextcloud. e.g. 'oidc_login_filter_allowed_values' => array('role1', 'role2')
      // 'oidc_login_filter_allowed_values' => array('user', 'admin'),

      // Use external storage instead of a symlink to the home directory
      // Requires the files_external app to be enabled
      'oidc_login_use_external_storage' => false,

      // Set OpenID Connect scope
      'oidc_login_scope' => 'profile email',    // the scope 'openid' is always added automatically

      // Run in LDAP proxy mode
      // In this mode, instead of creating users of its own, OIDC login
      // will get the existing user from an LDAP database and only
      // perform authentication with OIDC. All user data will be derived
      // from the LDAP database instead of the OIDC user response
      //
      // The `id` attribute in `oidc_login_attributes` must return the
      // "Internal Username" (see expert settings in LDAP integration)
      'oidc_login_proxy_ldap' => false,

      // Disable creation of users new to Nextcloud from OIDC login.
      // A user may be known to the IdP but not (yet) known to Nextcloud.
      // This setting controls what to do in this case.
      // - 'true' (default): if the user authenticates to the IdP but is not known to Nextcloud,
      //     then they will be returned to the login screen and not allowed entry;
      // - 'false': if the user authenticates but is not yet known to Nextcloud,
      //     then the user will be automatically created; note that with this setting,
      //     you will be allowing (or relying on) a third-party (the IdP) to create new users
      'oidc_login_disable_registration' => false,

      // Fallback to direct login if login from OIDC fails
      // Note that no error message will be displayed if enabled
      'oidc_login_redir_fallback' => false,

      // Use an alternative login page
      // This page will be php-included instead of a redirect if specified
      // In the example below, the PHP file `login.php` in `assets`
      // in nextcloud base directory will be included
      // Note: the PHP variable $OIDC_LOGIN_URL is available for redirect URI
      // Note: you may want to try setting `oidc_login_logout_url` to your
      // base URL if you face issues regarding re-login after logout
      'oidc_login_alt_login_page' => 'assets/login.php',

      // For development, you may disable TLS verification. Default value is `true`
      // which should be kept in production
      'oidc_login_tls_verify' => false,

      // If you get your groups from the oidc_login_attributes, you might want
      // to create them if they are not already existing, Default is `false`.
      'oidc_create_groups' => true,

      // Enable use of WebDAV via OIDC bearer token.
      'oidc_login_webdav_enabled' => false,

      // Enable authentication with user/password for DAV clients that do not
      // support token authentication (e.g. DAVx⁵)
      'oidc_login_password_authentication' => false,

      // The time in seconds used to cache public keys from provider.
      // The default value is 1 day.
      'oidc_login_public_key_caching_time' => 86400,

      // The minimum time in seconds to wait between requests to the jwks_uri endpoint.
      // Avoids that the provider will be DoSed when someone requests with unknown kids.
      // The default is 10 seconds.
      'oidc_login_min_time_between_jwks_requests' => 10,

      // The time in seconds used to cache the OIDC well-known configuration from the provider.
      // The default value is 1 day.
      'oidc_login_well_known_caching_time' => 86400,

      // If true, nextcloud will download user avatars on login.
      // This may lead to security issues as the server does not control
      // which URLs will be requested. Use with care.
      'oidc_login_update_avatar' => false,

      // If true, the default Nextcloud proxy won't be used to make internals OIDC call.
      // The default is false.
      'oidc_login_skip_proxy' => false,

      // Code challenge method for PKCE flow. 
      // Possible values are:
      //	- 'S256'
      //	- 'plain'
      // The default value is empty, which won't apply the PKCE flow.
      'oidc_login_code_challenge_method' => '',
    );
{{- end }}
  install_or_activate_nextcloud_apps.sh: |-
    #!/bin/bash

    # Array of Nextcloud app names to install (from command line arguments)
    apps=( "$@" )

    # Nextcloud installation details
    nextcloud_path="/var/www/html"
    nextcloud_occ_command="php $nextcloud_path/occ"
    nextcloud_url="http://localhost/status.php"

    # Function to check if Nextcloud is running
    function is_nextcloud_running() {
        curl -s --head "$nextcloud_url" | grep "200 OK" > /dev/null
    }

    echo "Waiting for Nextcloud to be running..."
    until is_nextcloud_running; do
        sleep 1
    done

    # Query installed apps
    nextcloud_installed_apps="$($nextcloud_occ_command app:list)"

    # Loop through the apps array and install/update each app
    for app in "${apps[@]}"
    do
        echo "Checking $app..."
        app_status="$(echo "$nextcloud_installed_apps" | sed -n -e "/^[^:]*:$/h;/$app/{x;p}")"
        if [[ -z $app_status ]]; then
            echo "Installing $app..."
            install_status="$($nextcloud_occ_command app:install $app)"
            if [[ $install_status =~ "installed" ]]; then
                echo "Installed $app"
            else
                echo "Failed to install $app"
            fi
        else
            echo "$app is already installed. Checking for updates..."
            update_status="$($nextcloud_occ_command app:update $app)"
            if [[ $update_status =~ "updated" ]]; then
                echo "Updated $app"
            else
                echo "$app is up to date"
            fi
        fi
        if [[ $app_status =~ "Disabled" ]]; then
            echo "Enabling $app..."
            enable_status="$($nextcloud_occ_command app:enable $app)"
            if [[ $enable_status =~ "enabled" ]]; then
                echo "Enabled $app"
            else
                echo "Failed to enable $app"
            fi
        fi
    done

# These settings are a 1:1 copy of the dependency chart 'nextcloud'
{{- range $key, $value := .Values.nextcloud.configs }}
  {{ $key }}: |-
{{ $value | indent 4 }}
{{- end }}
{{- if .Values.nextcloud.defaultConfigs }}
{{- if index .Values.nextcloud.defaultConfigs ".htaccess" }}
  .htaccess: |-
    # line below if for Apache 2.4
    <ifModule mod_authz_core.c>
    Require all denied
    </ifModule>
    # line below if for Apache 2.2
    <ifModule !mod_authz_core.c>
    deny from all
    </ifModule>
    # section for Apache 2.2 and 2.4
    <ifModule mod_autoindex.c>
    IndexIgnore *
    </ifModule>
{{- end }}
{{- if index .Values.nextcloud.defaultConfigs "redis.config.php" }}
  redis.config.php: |-
    <?php
    if (getenv('REDIS_HOST')) {
      $CONFIG = array (
        'memcache.distributed' => '\OC\Memcache\Redis',
        'memcache.locking' => '\OC\Memcache\Redis',
        'redis' => array(
          'host' => getenv('REDIS_HOST'),
          'port' => getenv('REDIS_HOST_PORT') ?: 6379,
          'password' => getenv('REDIS_HOST_PASSWORD'),
        ),
      );
    }
{{- end }}
{{- if index .Values.nextcloud.defaultConfigs "apache-pretty-urls.config.php" }}
  apache-pretty-urls.config.php: |-
    <?php
    $CONFIG = array (
      'htaccess.RewriteBase' => '/',
    );
{{- end }}
{{- if index .Values.nextcloud.defaultConfigs "apcu.config.php" }}
  apcu.config.php: |-
    <?php
    $CONFIG = array (
      'memcache.local' => '\OC\Memcache\APCu',
    );
{{- end }}
{{- if index .Values.nextcloud.defaultConfigs "apps.config.php" }}
  apps.config.php: |-
    <?php
    $CONFIG = array (
      "apps_paths" => array (
          0 => array (
                  "path"     => OC::$SERVERROOT."/apps",
                  "url"      => "/apps",
                  "writable" => false,
          ),
          1 => array (
                  "path"     => OC::$SERVERROOT."/custom_apps",
                  "url"      => "/custom_apps",
                  "writable" => true,
          ),
      ),
    );
{{- end }}
{{- if index .Values.nextcloud.defaultConfigs "autoconfig.php" }}
  autoconfig.php: |-
    <?php
    $autoconfig_enabled = false;
    if (getenv('SQLITE_DATABASE')) {
        $AUTOCONFIG["dbtype"] = "sqlite";
        $AUTOCONFIG["dbname"] = getenv('SQLITE_DATABASE');
        $autoconfig_enabled = true;
    } elseif (getenv('MYSQL_DATABASE') && getenv('MYSQL_USER') && getenv('MYSQL_PASSWORD') && getenv('MYSQL_HOST')) {
        $AUTOCONFIG["dbtype"] = "mysql";
        $AUTOCONFIG["dbname"] = getenv('MYSQL_DATABASE');
        $AUTOCONFIG["dbuser"] = getenv('MYSQL_USER');
        $AUTOCONFIG["dbpass"] = getenv('MYSQL_PASSWORD');
        $AUTOCONFIG["dbhost"] = getenv('MYSQL_HOST');
        $autoconfig_enabled = true;
    } elseif (getenv('POSTGRES_DB') && getenv('POSTGRES_USER') && getenv('POSTGRES_PASSWORD') && getenv('POSTGRES_HOST')) {
        $AUTOCONFIG["dbtype"] = "pgsql";
        $AUTOCONFIG["dbname"] = getenv('POSTGRES_DB');
        $AUTOCONFIG["dbuser"] = getenv('POSTGRES_USER');
        $AUTOCONFIG["dbpass"] = getenv('POSTGRES_PASSWORD');
        $AUTOCONFIG["dbhost"] = getenv('POSTGRES_HOST');
        $autoconfig_enabled = true;
    }
    if ($autoconfig_enabled) {
        $AUTOCONFIG["directory"] = getenv('NEXTCLOUD_DATA_DIR') ?: "/var/www/html/data";
    }
{{- end }}
{{- if index .Values.nextcloud.defaultConfigs "smtp.config.php" }}
  smtp.config.php: |-
    <?php
    if (getenv('SMTP_HOST') && getenv('MAIL_FROM_ADDRESS') && getenv('MAIL_DOMAIN')) {
      $CONFIG = array (
        'mail_smtpmode' => 'smtp',
        'mail_smtphost' => getenv('SMTP_HOST'),
        'mail_smtpport' => getenv('SMTP_PORT') ?: (getenv('SMTP_SECURE') ? 465 : 25),
        'mail_smtpsecure' => getenv('SMTP_SECURE') ?: '',
        'mail_smtpauth' => getenv('SMTP_NAME') && getenv('SMTP_PASSWORD'),
        'mail_smtpauthtype' => getenv('SMTP_AUTHTYPE') ?: 'LOGIN',
        'mail_smtpname' => getenv('SMTP_NAME') ?: '',
        'mail_smtppassword' => getenv('SMTP_PASSWORD') ?: '',
        'mail_from_address' => getenv('MAIL_FROM_ADDRESS'),
        'mail_domain' => getenv('MAIL_DOMAIN'),
      );
    }
{{- end }}
{{- end }}
